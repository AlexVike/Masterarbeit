# Dokumentation mithilfe von Github Copilot erstellt. Stellen an dem die Phasen des Chatbots verändert werden können sind mit ANPASSEN markiert.
import openai
import sqlite3
import time
import aiohttp
from typing import Optional
import asyncio
import json
import os
from messages import (
    prompt_list_fews_gpt4_anfang,
    prompt_list_fews_gpt4_mitte,
    prompt_list_fews_gpt4_ende,
    prompt_list_fews_gpt4_phase_4_anfang,
    prompt_list_fews_gpt4_phase_4_mitte,
    prompt_list_fews_gpt4_phase_4_ende,
    questions,
    summary_message,
    introduction_message,
    prompt_list_reflection_overcoming_stagnation,
    prompt_list_building_on_success,
    prompt_list_future_goals_planning_session2,
    prompt_list_setting_new_goals_session2,
    end_chat_zweite_session,
)

openai.api_key = ""


class OpenAiInterface:
    def __init__(self):
        print(os.getcwd())
        self.conn = sqlite3.connect(
            "Masterarbeit Code/Bot/Datenbank.db"
        )  # ANPASSEN
        self.cur = self.conn.cursor()
        self.question_progress = {}

    async def get_api_response(self, prompt, model="gpt-4-0314", max_tokens=250) -> str:
        print(prompt)

        url = "https://api.openai.com/v1/chat/completions"
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {openai.api_key}",
        }
        data = {
            "model": model,
            "messages": prompt,
            "max_tokens": max_tokens,
            "temperature": 1,
            "top_p": 1,
            "frequency_penalty": 0,
            "presence_penalty": 0.6,
        }

        resp = None  # Initialize resp

        async with aiohttp.ClientSession() as session:
            try:
                async with session.post(
                    url, headers=headers, data=json.dumps(data)
                ) as resp:
                    response = await resp.json()
                    print("Response received")
                    print(response)

                    if resp.status != 200:
                        raise Exception(response["error"]["message"])

            except Exception as e:
                print(f"Error encountered: {e}")

                # Check if resp exists and has a status attribute
                if resp and hasattr(resp, 'status') and resp.status == 429:
                    print("Switching to gpt-3.5-turbo due to token limit")
                    return await self.get_api_response(prompt, model="gpt-3.5-turbo")
                else:
                    raise e  # Re-raise the original exception if resp is not set or doesn't have a status

        choices = response.get("choices")[0]
        text = "AI:" + choices["message"]["content"]
        return text


    async def update_database(
            self,
            chat_id: int,
            message: str,
            response: str,
            phase: float = 0,
            Gruppe: str = "LC",
        ):
            """
            Inserts a new record into the database table 'Master_Test' with the provided parameters.

            Parameters:
            - chat_id (int): The ID of the chat.
            - message (str): The message sent by the user.
            - response (str): The response generated by the chatbot.
            - phase (float, optional): The phase of the conversation. Default is 0.
            - Gruppe (str, optional): The group identifier. Default is 'LC'.
            """
            current_timestamp = int(time.time())
            self.cur.execute(
                "INSERT INTO Master_Test (ChatID, Human, Chatbot, Phase, Gruppe, timestamp) VALUES (?, ?, ?, ?, ?, ?)",
                (chat_id, message, response, phase, Gruppe, current_timestamp),
            )
            self.conn.commit()

    async def insert_into_anmeldung(self, chat_id: int):
        """
        The function inserts a record into a database table called "Anmeldung_zweite_S" with the values
        "Ja" for the "Anmeldung" column, the provided "chat_id" for the "ChatID" column, and the current
        Unix timestamp in seconds for the "timestamp" column.
        
        :param chat_id: The chat_id parameter is an integer that represents the unique identifier of a
        chat or conversation. It is used to associate the insertion with a specific chat or conversation
        in the database
        :type chat_id: int
        """
        # Der aktuelle Unix-Timestamp in Sekunden
        current_timestamp = int(time.time())

        self.cur.execute(
            "INSERT INTO Anmeldung_zweite_S (Anmeldung, ChatID, timestamp) VALUES (?, ?, ?)",
            ("Ja", chat_id, current_timestamp),
        )
        self.conn.commit()

    async def insert_into_end_chat(self, chat_id: int):
        """
        The function inserts a chat ID and current timestamp into a database table called "Chat_end".
        
        :param chat_id: The chat_id parameter is an integer that represents the unique identifier of a
        chat. It is used to identify which chat the end timestamp should be inserted into
        :type chat_id: int
        """
        # Der aktuelle Unix-Timestamp in Sekunden
        current_timestamp = int(time.time())

        
        self.cur.execute(
            "INSERT INTO Chat_end (ChatID, timestamp) VALUES (?, ?)",
            (chat_id, current_timestamp),
        )
        self.conn.commit()

    async def count_interactions(self, chat_id: int) -> int:
        """
        The function `count_interactions` retrieves the count of interactions for a given chat ID from a
        database table.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the ID of a chat
        :type chat_id: int
        :return: The count of interactions for the given chat_id.
        """
        self.cur.execute(
            "SELECT COUNT(*) FROM Master_Test WHERE ChatID = ?", (chat_id,)
        )
        count = self.cur.fetchone()[0]
        return count

    async def get_last_phase(self, chat_id: int) -> Optional[float]:
        """
        The function `get_last_phase` retrieves the last recorded phase value for a given chat ID from a
        database table.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier of a
        chat. It is used to filter the query and retrieve the last phase value associated with that
        specific chat
        :type chat_id: int
        :return: the value of the "Phase" column from the last row in the "Master_Test" table where the
        "ChatID" column matches the provided chat_id. If there is no matching row, it returns None.
        """
        self.cur.execute(
            "SELECT Phase FROM Master_Test WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 1",
            (chat_id,),
        )
        result = self.cur.fetchone()
        return result[0] if result else None

    async def create_prompt(self, chat_id: int):
        """
        The `create_prompt` function selects messages based on the phase count and appends them to a
        list of messages.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier for
        a chat conversation. It is used to retrieve the relevant data from the database for that
        specific chat conversation
        :type chat_id: int
        :return: a list of messages. Each message is represented as a dictionary with two keys: "role"
        and "content". The "role" key specifies whether the message is from the user or the assistant,
        and the "content" key contains the text of the message.
        """
        self.cur.execute(
            "SELECT Human, Chatbot, Phase FROM Master_Test WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 10",
            (chat_id,),
        )
        data = self.cur.fetchall()
        phase_2_count = sum(1 for row in data if row[2] == 2.0)
        print(f"Phase 2 count: {phase_2_count}")
        phase_2_1_count = sum(1 for row in data if row[2] == 2.1)
        print(f"Phase 2.1 count: {phase_2_1_count}")

        if phase_2_1_count == 0:
            # Nachrichten basierend auf der Anzahl der Phase 2.0 selektieren
            if phase_2_count <= 2:
                messages = prompt_list_fews_gpt4_anfang.copy()
            elif 3 <= phase_2_count <= 7:
                messages = prompt_list_fews_gpt4_mitte.copy()
            else:
                messages = prompt_list_fews_gpt4_ende.copy()
        else:
            if phase_2_1_count <= 2:
                messages = prompt_list_fews_gpt4_anfang.copy()
            elif 3 <= phase_2_1_count <= 7:
                messages = prompt_list_fews_gpt4_mitte.copy()
            else:
                messages = prompt_list_fews_gpt4_ende.copy()

        
        for row in reversed(data[:5]):
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "assistant", "content": ai_text})

        return messages

    async def phase_drei(self, chat_id: int, message: str) -> str:
        """
        The function `phase_drei` handles the logic for asking scaling questions and progressing through
        a series of questions in a chatbot conversation.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier for
        a chat or conversation. It is used to keep track of the progress and state of the conversation
        for each user
        :type chat_id: int
        :param message: The `message` parameter in the `phase_drei` function is a string that represents
        the user's input or response to a question. It is used to determine the next step or question in
        the conversation flow
        :type message: str
        :return: a string. The specific string that is returned depends on the current question index
        and the input message.
        """
        # Check if scaling question has been asked yet
        if chat_id not in self.question_progress:
            self.question_progress[
                chat_id
            ] = -3  
        current_question_index = self.question_progress[chat_id]
        print(f"Current question index: {current_question_index}")

        # Handle scaling question logic
        if current_question_index == -3:
            self.question_progress[chat_id] += 1
            zusammenfassung = await self.create_prompt_zusammenfassen_gpt3_5(chat_id, 2)
            print(zusammenfassung)
            skalierungsfrage = '\n\nAuf einer Skala von 1 bis 10, wobei 1 "unzureichend informiert" und 10 "ausreichend informiert" bedeutet, wie gut fühlst du dich informiert, um ein klares Ziel zu diesem Thema zu formulieren?'
            print(skalierungsfrage)
            await self.update_database(
                chat_id, message, zusammenfassung + skalierungsfrage, phase=3
            )
            print(zusammenfassung + skalierungsfrage)
            return zusammenfassung + skalierungsfrage
        elif current_question_index == -2:
            try:
                user_rating = int(message)
                if user_rating < 5:
                    del self.question_progress[
                        chat_id
                    ]  # remove from phase_zwei processing
                    phase_zwei_wiederholen = f"Eine {user_rating}? Lass uns nochmal genauer über das Problem reden."
                    await self.update_database(
                        chat_id, message, phase_zwei_wiederholen, phase=2.1
                    )
                    return phase_zwei_wiederholen
                else:
                    self.question_progress[chat_id] += 2
                    await self.update_database(
                        chat_id, message, introduction_message, phase=3
                    )
                    return introduction_message
            except ValueError:
                fehler_zahl = "Bitte geben Sie eine gültige Zahl zwischen 1 und 10 an."
                await self.update_database(chat_id, message, fehler_zahl, phase=3)
                return fehler_zahl

        if current_question_index == -1:
            self.question_progress[chat_id] += 1
            await self.update_database(chat_id, message, introduction_message, phase=3)
            return introduction_message
        elif current_question_index < len(questions):
            print(current_question_index)
            next_question = questions[current_question_index]
            self.question_progress[chat_id] += 1
            await self.update_database(chat_id, message, next_question, phase=3)
            return next_question
        else:
            # Nachdem alle Fragen beantwortet wurden
            await self.update_database(chat_id, message, summary_message, phase=4)
            del self.question_progress[chat_id]  # Fortschritt entfernen
            return summary_message

    async def get_bot_response_phase2(self, chat_id: int, message: str) -> str:
        """
        The function `get_bot_response_phase2` takes a chat ID and a message as input, retrieves a bot
        response, updates the database with the chat interaction, and returns the bot response.
        
        :param chat_id: The chat_id parameter is an integer that represents the unique identifier for a
        conversation or chat session. It is used to identify and track the conversation between the user
        and the bot
        :type chat_id: int
        :param message: The `message` parameter is a string that represents the user's input message. It
        is the text that the user sends to the bot for processing
        :type message: str
        :return: the bot's response as a string.
        """
        bot_response = await self.get_response(chat_id, message)
        anzahl_turns = await self.count_interactions(chat_id)
        if anzahl_turns == 11:  # ANPASSEN
            await self.update_database(chat_id, message, bot_response, phase=3)
        else:
            await self.update_database(chat_id, message, bot_response, phase=2)
        print("Done processing")
        return bot_response

    async def get_bot_response_phase2_1(self, chat_id: int, message: str) -> str:
        """
        The function `get_bot_response_phase2_1` checks the count of a specific phase in the database
        and returns a bot response based on the count.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier for
        a chat or conversation. It is used to identify and track the conversation between the user and
        the bot
        :type chat_id: int
        :param message: The `message` parameter is a string that represents the user's input message or
        query. It is the text that the user sends to the bot for processing and generating a response
        :type message: str
        :return: The function `get_bot_response_phase2_1` returns a string.
        """
        self.cur.execute(
            "SELECT COUNT(*) FROM Master_Test WHERE ChatID = ? AND Phase = 2.1",
            (chat_id,),
        )
        count = self.cur.fetchone()[0]
        if count == 20:  # ANPASSEN
            zusammenfassung = await self.create_prompt_zusammenfassen_gpt3_5(
                chat_id=chat_id, phase=3
            )
            await self.update_database(chat_id, message, zusammenfassung, phase=3)
            self.question_progress[chat_id] = 0
            return zusammenfassung + "\n\n" + introduction_message
        if (
            count % 10 == 0
        ):  # Überprüfen, ob die Anzahl ein Vielfaches von 10 ist. # ANPASSEN
            bot_response = await self.get_response(chat_id, message)
            await self.update_database(chat_id, message, bot_response, phase=3)
            return bot_response
        else:
            bot_response = await self.get_response(chat_id, message)
            await self.update_database(chat_id, message, bot_response, phase=2.1)
            return bot_response

    async def get_bot_response_phase4(self, chat_id: int, message: str) -> str:
        """
        The function `get_bot_response_phase4` retrieves the bot's response based on the user's message
        and updates the database accordingly.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier for
        a chat conversation. It is used to identify and track the conversation in the database
        :type chat_id: int
        :param message: The `message` parameter is a string that represents the user's input message. It
        is the text that the user sends to the bot
        :type message: str
        :return: The function `get_bot_response_phase4` returns a string, which is the bot's response to
        the user's message.
        """
        self.cur.execute(
            "SELECT COUNT(*) FROM Master_Test WHERE ChatID = ? AND Phase = 4.0",
            (chat_id,),
        )
        count = self.cur.fetchone()[0]
        if count == 1:
            bot_response = "Prima! Ich danke dir für deine aktive Mitarbeit. Zum Abschluss besprechen wir gemeinsam, wie du dein definiertes Ziel in die Praxis umsetzen kannst. Wie kannst du dein formuliertes Ziel im Alltag umsetzen? Was wäre ein erster kleiner Schritt?"
            await self.update_database(chat_id, message, bot_response, phase=4)
            zusammenfassung = await self.create_prompt_zusammenfassen_gpt3_5(
                chat_id, phase=3
            )
            print(zusammenfassung)
        elif count == 8:  # ANPASSEN
            prompt = await self.create_prompt_zusammenfassen(chat_id)
            prompt.append(
                {
                    "role": "user",
                    "content": "Prompt: "
                    + "Fasse den bisherigen Chatverlauf zusammen, um das Ende einzuleiten. Verabschiede dich vom User.",
                }
            )
            bot_response = (
                await self.get_api_response(prompt, "gpt-3.5-turbo", 500)
                + "\n\n"
                + "Möchtest du bei der zweiten Session mitmachen? Wenn ja, dann schreibe bitte 'Ja'. Wenn nein, dann schreibe bitte 'Nein'.\n Nach der Beantwortung dieser Frage wirst du zu dem Gewinnspiel weitergeleitet."
            )
            if bot_response:
                pos: int = bot_response.find("\nAI: ")
                bot_response = bot_response[pos + 4 :]
            else:
                bot_response = "Something went wrong..."
            await self.update_database(chat_id, message, bot_response, phase=5)

        else:
            bot_response = await self.create_prompt_phase_4(chat_id, message)
            await self.update_database(chat_id, message, bot_response, phase=4)
        return bot_response

    async def get_response(self, chat_id: int, message: str) -> str:
        """
        The `get_response` function takes a chat ID and a message as input, creates a prompt using the
        chat ID, appends the user's message to the prompt, retrieves a response from an API, and returns
        the bot's response.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier for
        a chat or conversation. It is used to identify the specific conversation for which the response
        is being generated
        :type chat_id: int
        :param message: The `message` parameter is a string that represents the user's input message. It
        is the content that the user wants to send to the chatbot
        :type message: str
        :return: a string, which is the response generated by the AI chatbot.
        """
        prompt = await self.create_prompt(chat_id)
        prompt.append({"role": "user", "content": "Prompt: " + message})
        bot_response = await self.get_api_response(prompt)
        if bot_response:
            pos: int = bot_response.find("\nAI: ")
            bot_response = bot_response[pos + 4 :]
        else:
            bot_response = "Something went wrong..."
        return bot_response

    async def create_prompt_zusammenfassen(self, chat_id: int):
        """
        The function `create_prompt_zusammenfassen` retrieves the most recent 30 messages from a
        database for a given chat ID and returns them in a list of dictionaries representing the
        messages.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier of a
        chat conversation. It is used to retrieve the messages from the database for a specific chat
        conversation
        :type chat_id: int
        :return: The function `create_prompt_zusammenfassen` returns a list of dictionaries representing
        the messages in a chat conversation. Each dictionary in the list has two key-value pairs: "role"
        and "content". The "role" key represents the role of the message sender, which can be either
        "user" or "system". The "content" key represents the content of the message.
        """
        
        self.cur.execute(
            "SELECT Human, Chatbot FROM Master_Test WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 30",
            (chat_id,),
        )
        data = self.cur.fetchall()

        
        messages = []

        
        for row in data:
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "system", "content": ai_text})

        
        messages.reverse()

        return messages

    async def create_prompt_zusammenfassen_gpt3_5(self, chat_id: int, phase):
        """
        The function `create_prompt_zusammenfassen_gpt3_5` retrieves the chat history from a database,
        appends it to a list of messages, prompts the user to summarize the chat history in one
        sentence, sends the messages to the GPT-3.5 Turbo model for a response, and stores the generated
        summary in the database.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier of a
        chat conversation. It is used to retrieve the conversation data from the database and to store
        the generated summary in the Zusammenfassung_chat table
        :type chat_id: int
        :param phase: The `phase` parameter in the `create_prompt_zusammenfassen_gpt3_5` function is
        used to specify the phase of the chat conversation. It is passed as an argument to the function
        and is used to store the phase information in the database along with the chat summary
        :return: The function `create_prompt_zusammenfassen_gpt3_5` returns the zusammenfassung
        (summary) of the chat conversation.
        """
        print("Creating zusammenfassung")
        self.cur.execute(
            "SELECT Human, Chatbot FROM Master_Test WHERE ChatID = ?", (chat_id,)
        )
        data = self.cur.fetchall()

        
        messages = [
            {
                "role": "system",
                "content": "Verhalte dich wie ein Lerncoach. Weiche nicht von deiner Rolle. Fördere individuelles Lernen und stärke Selbstmanagement. Berücksichtige Motivation und unterstütze selbstreguliertes Lernen. Fokus sehr wichtig: Denkweise des Lernenden, nicht Lösungen. Stelle pro Turn eine Frage. Keine Ratschläge oder Richtungen.",
            }
        ]

        
        for row in data:
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "assistant", "content": ai_text})

        messages.append(
            {
                "role": "user",
                "content": "Prompt: "
                + "Fasse den bisherigen Chatverlauf in einem Satz zusammen. Fange an mit: Lass uns den bisherigen Chatverlauf zusammenfassen. Wir haben uns über folgendes unterhalten:...",
            }
        )
        zusammenfasssung = await self.get_api_response(messages, "gpt-3.5-turbo", 500)
        current_timestamp = int(time.time())
        self.cur.execute(
            "INSERT INTO Zusammenfassung_chat (ChatID, Zusammenfassung, Phase, timestamp) VALUES (?, ?, ?, ?)",
            (chat_id, zusammenfasssung, phase, current_timestamp),
        )
        self.conn.commit()
        if zusammenfasssung:
            pos: int = zusammenfasssung.find("\nAI: ")
            zusammenfasssung = zusammenfasssung[pos + 4 :]
        else:
            zusammenfasssung = "Something went wrong..."

        return zusammenfasssung

    async def create_prompt_phase_4(self, chat_id: int, message: str):
        """
        The function `create_prompt_phase_4` retrieves data from a database, determines the number of
        messages in phase 4, selects the appropriate prompt messages based on the count, adds user and
        AI messages to the list, appends the user's prompt message, and returns the bot's response.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier of a
        chat conversation. It is used to retrieve relevant data from the database for the specified chat
        conversation
        :type chat_id: int
        :param message: The `message` parameter is a string that represents the user's input message. It
        is used to append the user's prompt to the list of messages before sending it to the API for
        generating a response
        :type message: str
        :return: the response generated by the AI assistant based on the given messages.
        """
        self.cur.execute(
            "SELECT Zusammenfassung FROM Zusammenfassung_chat WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 1",
            (chat_id,),
        )
        data = self.cur.fetchone()[0]
        self.cur.execute(
            "SELECT Human, Chatbot FROM Master_Test WHERE ChatID = ? AND Phase = 4.0 ORDER BY ROWID ASC LIMIT -1 OFFSET 2",
            (chat_id,),
        )
        data2 = self.cur.fetchall()

        # Bestimme die Anzahl der Nachrichten in Phase 4
        phase_4_count = len(data2)

        # Wähle das richtige Nachrichtenobjekt basierend auf der Nachrichtenanzahl
        if phase_4_count <= 1:
            messages = prompt_list_fews_gpt4_phase_4_anfang.copy()
        elif 2 <= phase_4_count <= 4:
            messages = prompt_list_fews_gpt4_phase_4_mitte.copy()
        else:
            messages = prompt_list_fews_gpt4_phase_4_ende.copy()

        # Fügen Sie die Benutzer- und AINachrichten zur Liste hinzu
        messages.append({"role": "user", "content": data})
        messages.append(
            {
                "role": "assistant",
                "content": "Wie kannst du dein formuliertes Ziel im Alltag umsetzen? Was wäre ein erster kleiner Schritt?",
            }
        )
        for row in data2[:5]:
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "assistant", "content": ai_text})

        messages.append({"role": "user", "content": "Prompt: " + message})
        bot_response = await self.get_api_response(messages)
        if bot_response:
            pos: int = bot_response.find("\nAI: ")
            bot_response = bot_response[pos + 4 :]
        else:
            bot_response = "Something went wrong..."
        return bot_response

    async def get_unique_chat_ids_count(self) -> int:
        """
        The function `get_unique_chat_ids_count` retrieves the count of distinct chat IDs from a
        database table.
        :return: the count of unique chat IDs from the "Master_Test" table.
        """
        self.cur.execute("SELECT COUNT(DISTINCT ChatID) FROM Master_Test")
        unique_chat_ids_count = self.cur.fetchone()[0]

        return unique_chat_ids_count

    async def is_chat_id_in_database(self, chat_id):
        """
        The function checks if a given chat ID is present in a database table.
        
        :param chat_id: The chat_id parameter is the unique identifier for a chat or conversation in a
        messaging platform. It is used to check if the chat_id is present in a database table called
        "Master_Test"
        :return: a boolean value indicating whether the given chat_id exists in the database.
        """
        self.cur.execute(
            "SELECT COUNT(*) FROM Master_Test WHERE ChatID = ?", (chat_id,)
        )
        is_chat_id_in_db = self.cur.fetchone()[0] > 0

        return is_chat_id_in_db

   

    async def get_combined_info(self, chat_id):
        """
        The `get_combined_info` function retrieves combined information from multiple tables based on a
        given chat ID, while the `check_chat_end` function checks if a chat has ended based on its ID.
        
        :param chat_id: The `chat_id` parameter is used to identify a specific chat or conversation. It
        is passed as an argument to the `get_combined_info` and `check_chat_end` methods to retrieve
        information related to that particular chat
        :return: The `get_combined_info` function returns a tuple containing the following values:
        - `is_chat_id_in_db`: a boolean indicating whether the chat_id exists in the database
        - `group_by_chat_id`: the value of the "Gruppe" column from the "Master_Test" table if it
        exists, otherwise None
        - `anmeldung`: the value of the "Anmeldung" column from
        """
        query = """
        WITH CombinedResults AS (
            SELECT 
                Gruppe, 
                NULL as Anmeldung, 
                NULL as Timestamp
            FROM Master_Test 
            WHERE ChatID = ?
            UNION ALL
            SELECT 
                NULL, 
                Anmeldung, 
                timestamp
            FROM Anmeldung_zweite_S 
            WHERE ChatID = ?
            UNION ALL
            SELECT 
                NULL, 
                NULL, 
                NULL
            FROM Chat_end 
            WHERE ChatID = ?
        )
        SELECT 
            MAX(Gruppe) as Gruppe,
            CASE WHEN MAX(Gruppe) IS NOT NULL THEN 1 ELSE 0 END as IsInDB,
            MAX(Anmeldung) as Anmeldung,
            MAX(Timestamp) as Timestamp,
            CASE WHEN EXISTS (SELECT 1 FROM Chat_end WHERE ChatID = ?) THEN 1 ELSE 0 END as IsChatEnd
        FROM CombinedResults;
        """

        self.cur.execute(query, (chat_id, chat_id, chat_id, chat_id))
        result = self.cur.fetchone()

        group_by_chat_id = result[0] if result[1] > 0 else None
        is_chat_id_in_db = result[1] > 0
        anmeldung = result[2] if result[2] else None
        timestamp = result[3] if result[3] else None
        is_chat_end = result[4] > 0

        return (is_chat_id_in_db, group_by_chat_id, anmeldung, timestamp, is_chat_end)

    async def check_chat_end(self, chat_id):
        """
        The function `check_chat_end` checks if a chat has ended by querying the database for the
        existence of a record in the `Chat_end` table with the given `chat_id`.
        
        :param chat_id: The `chat_id` parameter is the identifier for a specific chat. It is used to
        query the database and check if the chat has ended
        :return: a boolean value indicating whether the chat with the given chat_id has ended or not. If
        the result is greater than 0, it means the chat has ended and the function returns True.
        Otherwise, it returns False.
        """
        query = """
        SELECT CASE WHEN EXISTS (SELECT 1 FROM Chat_end WHERE ChatID = ?) THEN 1 ELSE 0 END as IsChatEnd
        """
        self.cur.execute(query, (chat_id,))
        result = self.cur.fetchone()

        return result[0] > 0

    ##################### Neutraler Chatbot #####################

    async def update_database_neutral(
            self,
            chat_id: int,
            message: str,
            response: str,
            phase: float = 0,
            Gruppe: str = "NC",
        ):
            """
            Update the database with a neutral entry.

            Parameters:
            - chat_id (int): The ID of the chat.
            - message (str): The message from the user.
            - response (str): The response from the chatbot.
            - phase (float, optional): The phase of the conversation. Default is 0.
            - Gruppe (str, optional): The group of the conversation. Default is "NC".
            """
            current_timestamp = int(time.time())
            self.cur.execute(
                "INSERT INTO Master_Test (ChatID, Human, Chatbot, Phase, Gruppe, timestamp) VALUES (?, ?, ?, ?, ?, ?)",
                (chat_id, message, response, phase, Gruppe, current_timestamp),
            )
            self.conn.commit()

    async def create_prompt_neutral(self, chat_id: int):
        """
        The function `create_prompt_neutral` retrieves the chat history for a given chat ID and creates
        a prompt for a neutral assistant, including system instructions and previous user and assistant
        messages.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier of a
        chat conversation. It is used to retrieve the chat history for a specific conversation from a
        database table
        :type chat_id: int
        :return: The function `create_prompt_neutral` returns a list of messages. Each message is
        represented as a dictionary with two keys: "role" and "content". The "role" key represents the
        role of the message sender, which can be "system", "user", or "assistant". The "content" key
        represents the content of the message, which can be a system instruction, user input,
        """
        self.cur.execute(
            "SELECT Human, Chatbot FROM Master_Test WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 10",
            (chat_id,),
        )
        data = self.cur.fetchall()
        print(f"Das ist der Chatverlauf: {data}")
        messages = [
            {
                "role": "system",
                "content": "Verhalte dich wie ein neutraler Assistent. Helfe dem Klienten eine Lösung zu finden. Versuche den Klienten zu einem aktiven Gespräch zu animieren, frage nach Kontext. Stelle pro Turn eine Frage. Halte deinen Redeanteil kurz."
            }
        ]

        
        for row in reversed(data[:3]):
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "assistant", "content": ai_text})

        return messages

    async def get_response_neutral(self, chat_id: int, message: str) -> str:
        """
        The function `get_response_neutral` takes a chat ID and a message as input, checks the count of
        interactions, and returns a bot response based on the count. If the count is 15, it creates a
        summary using GPT-3 and prompts the user to participate in a second session. If the count is
        greater than 15, it returns a message indicating that the chatbot has already been completed.
        Otherwise, it appends the user message to the prompt, generates a bot response using an API,
        updates the database, and returns the bot response.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier for
        a chat session. It is used to track and identify the conversation between the user and the
        chatbot
        :type chat_id: int
        :param message: The `message` parameter is a string that represents the user's input message. It
        is the text that the user sends to the chatbot
        :type message: str
        :return: The function `get_response_neutral` returns a string.
        """
        count = await self.count_interactions_neutral(chat_id)
        if count == 15:  # ANPASSEN
            zusammenfassung = await self.create_prompt_zusammenfassen_gpt3_5_neutral(
                chat_id
            )
            await self.update_database_neutral(
                chat_id, message, zusammenfassung, phase=5
            )
            return (
                zusammenfassung
                + "\n\n"
                + "Möchtest du bei der zweiten Session mitmachen? Wenn ja, dann schreibe bitte 'Ja'. Wenn nein, dann schreibe bitte 'Nein'.\n Nach der Beantwortung dieser Frage wirst du zu dem Gewinnspiel weitergeleitet."
            )
        elif count > 15:  # ANPASSEN
            return "Du hast den Chatbot bereits abgeschlossen"
        else:
            prompt = await self.create_prompt_neutral(chat_id)
            prompt.append({"role": "user", "content": "Prompt: " + message})
            bot_response = await self.get_api_response(prompt, max_tokens=500)

            if bot_response:
                pos: int = bot_response.find("\nChatbot: ")
                bot_response = bot_response[pos + 4 :]
            else:
                bot_response = "Something went wrong..."
            await self.update_database_neutral(chat_id, message, bot_response)
            return bot_response

    async def create_prompt_zusammenfassen_gpt3_5_neutral(self, chat_id: int):
        """
        The function `create_prompt_zusammenfassen_gpt3_5_neutral` retrieves the chat history from a
        database, generates a prompt for summarizing the chat history, sends the prompt to the GPT-3.5
        Turbo model for generating a summary, and stores the summary in another database.
        
        :param chat_id: The `chat_id` parameter is an integer that represents the unique identifier of a
        chat conversation. It is used to retrieve the conversation data from the database and store the
        generated summary in the Zusammenfassung_chat table along with the chat_id and timestamp
        :type chat_id: int
        :return: The function `create_prompt_zusammenfassen_gpt3_5_neutral` returns the summarized chat
        history as a string.
        """
        print("Creating zusammenfassung")
        self.cur.execute(
            "SELECT Human, Chatbot FROM Master_Test WHERE ChatID = ?", (chat_id,)
        )
        data = self.cur.fetchall()

        
        messages = [
            {
                "role": "system",
                "content": "Du bist ein Chatbot, der versucht Studenten beim lernen zu helfen. Halte die Antowrten kurz",
            }
        ]

        
        for row in data:
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "assistant", "content": ai_text})

        messages.append(
            {
                "role": "user",
                "content": "Prompt: "
                + "Fasse den bisherigen Chatverlauf in einem Satz zusammen. Fange an mit: Lass uns den bisherigen Chatverlauf zusammenfassen. Wir haben uns über folgendes unterhalten:...\n",
            }
        )
        zusammenfasssung = await self.get_api_response(messages, "gpt-3.5-turbo", 300)
        current_timestamp = int(time.time())
        self.cur.execute(
            "INSERT INTO Zusammenfassung_chat (ChatID, Zusammenfassung, timestamp) VALUES (?, ?, ?)",
            (chat_id, zusammenfasssung, current_timestamp),
        )
        self.conn.commit()
        if zusammenfasssung:
            pos: int = zusammenfasssung.find("\nAI: ")
            zusammenfasssung = zusammenfasssung[pos + 4 :]
        else:
            zusammenfasssung = "Something went wrong..."

        return zusammenfasssung

    async def count_interactions_neutral(self, chat_id: int) -> int:
        """
        The function `count_interactions_neutral` counts the number of interactions in a database table
        for a given chat ID.
        
        :param chat_id: The chat_id parameter is an integer that represents the unique identifier for a
        chat or conversation
        :type chat_id: int
        :return: the count of interactions with a neutral sentiment for a given chat_id.
        """
        self.cur.execute(
            "SELECT COUNT(*) FROM Master_Test WHERE ChatID = ?", (chat_id,)
        )
        count = self.cur.fetchone()[0]
        return count

    ####################################################################################################################################################################################################################
    # Zweite Session
    async def get_last_phase_zweite_session(self, chat_id: int) -> Optional[float]:
        self.cur.execute(
            "SELECT Phase FROM Zweite_S WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 1",
            (chat_id,),
        )
        result = self.cur.fetchone()
        return result[0] if result else None

    async def get_last_summary_by_id(self, chat_id: int) -> Optional[str]:
        self.cur.execute(
            "SELECT Zusammenfassung FROM Zusammenfassung_chat WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 1",
            (chat_id,),
        )
        result = self.cur.fetchone()
        if result:
            # Versuche beide Trennstrings
            parts_dot = result[0].split(
                "Lass uns den bisherigen Chatverlauf zusammenfassen. "
            )
            parts_colon = result[0].split(
                "Lass uns den bisherigen Chatverlauf zusammenfassen: "
            )

            
            summary_dot = parts_dot[1] if len(parts_dot) > 1 else ""
            summary_colon = parts_colon[1] if len(parts_colon) > 1 else ""

            if summary_dot or summary_colon:
                return max(summary_dot, summary_colon, key=len)
            else:
                return "keine Informationen verfügbar"
        else:
            return "keine Informationen verfügbar"

    async def update_database_zweite_session(
        self,
        chat_id: int,
        message: str,
        response: str,
        phase: float = 0,
        Gruppe: str = "LC",
    ):
        current_timestamp = int(time.time())
        self.cur.execute(
            "INSERT INTO Zweite_S (ChatID, Human, Chatbot, Phase, Gruppe, timestamp) VALUES (?, ?, ?, ?, ?, ?)",
            (chat_id, message, response, phase, Gruppe, current_timestamp),
        )
        self.conn.commit()

    async def insert_into_fortschritt(self, chat_id: int, fortschritt: str):
        # Der aktuelle Unix-Timestamp in Sekunden
        current_timestamp = int(time.time())

        self.cur.execute(
            "INSERT INTO Fortschritte (ChatID, Fortschritt, timestamp) VALUES (?, ?, ?)",
            (chat_id, fortschritt, current_timestamp),
        )
        self.conn.commit()

    async def get_bot_response_phase2_zweite_session(
        self, chat_id: int, message: str
    ) -> str:
        bot_response = await self.get_response_zweite_session(chat_id, message)
        anzahl_turns = await self.count_interactions_zweite_session(chat_id)
        if anzahl_turns == 11:  # ANPASSEN
            await self.update_database_zweite_session(
                chat_id, message, bot_response, phase=3
            )
        else:
            await self.update_database_zweite_session(
                chat_id, message, bot_response, phase=2
            )
        print("Done processing")
        return bot_response

    async def get_response_zweite_session(self, chat_id: int, message: str) -> str:
        prompt = await self.create_prompt_zweite_session(chat_id)
        prompt.append({"role": "user", "content": "Prompt: " + message})
        bot_response = await self.get_api_response(prompt)
        if bot_response:
            pos: int = bot_response.find("\nAI: ")
            bot_response = bot_response[pos + 4 :]
        else:
            bot_response = "Something went wrong..."
        return bot_response

    async def create_prompt_zweite_session(self, chat_id: int):
        self.cur.execute(
            "SELECT Human, Chatbot, Phase FROM Zweite_S WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 10",
            (chat_id,),
        )
        data = self.cur.fetchall()
        self.cur.execute(
            "SELECT Fortschritt FROM Fortschritte WHERE ChatID = ? ORDER BY timestamp DESC LIMIT 1",
            (chat_id,),
        )
        fortschritt_data = self.cur.fetchone()

        # Fortschritt extrahieren, falls vorhanden
        fortschritt = fortschritt_data[0] if fortschritt_data else None
        if fortschritt == "Ja":
            print("Fortschritt ist Ja")
            messages = prompt_list_building_on_success.copy()
        else:
            print("Fortschritt ist Nein")
            messages = prompt_list_reflection_overcoming_stagnation.copy()

        
        for row in reversed(data[:5]):
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "assistant", "content": ai_text})

        return messages

    async def get_bot_response_phase3_zweite_session(
        self, chat_id: int, message: str
    ) -> str:
        zusammenfassung = await self.create_prompt_zusammenfassen_gpt3_5_zweite_session(
            chat_id, 20
        )
        bot_response = "Denke über das Ziel, das du in unserer ersten Sitzung gesetzt hast, und über deine bisherigen Ergebnisse sowie unsere heutige Diskussion nach. Welches konkrete Ergebnis würde dich am Ende dieser zweiten Session zufriedenstellen?"
        await self.update_database_zweite_session(
            chat_id, message, bot_response, phase=4
        )
        print("Done processing")
        return zusammenfassung + "\n" + bot_response

    async def get_bot_response_phase4_zweite_session(
        self, chat_id: int, message: str
    ) -> str:
        self.cur.execute(
            "SELECT COUNT(*) FROM Zweite_S WHERE ChatID = ? AND Phase = 4.0",
            (chat_id,),
        )
        count = self.cur.fetchone()[0]
        if count == 1:
            bot_response = "Wie könntest du dieses Ergebnis erreichen? Was wäre ein erster kleiner Schritt?"
            await self.update_database_zweite_session(
                chat_id, message, bot_response, phase=4
            )
            zusammenfassung = (
                await self.create_prompt_zusammenfassen_gpt3_5_zweite_session(
                    chat_id, phase=30
                )
            )
            print(zusammenfassung)
        elif count == 8:  # ANPASSEN
            prompt = await self.create_prompt_zusammenfassen_zweite_session(chat_id)
            prompt.append(
                {
                    "role": "user",
                    "content": "Prompt: "
                    + "Fasse den bisherigen Chatverlauf zusammen, um das Ende einzuleiten. Verabschiede dich vom User.",
                }
            )
            bot_response = (
                await self.get_api_response(prompt, "gpt-3.5-turbo", 500)
                + "\n\n"
                + end_chat_zweite_session.format(chat_id)
            )
            if bot_response:
                pos: int = bot_response.find("\nAI: ")
                bot_response = bot_response[pos + 4 :]
            else:
                bot_response = "Something went wrong..."
            await self.update_database_zweite_session(
                chat_id, message, bot_response, phase=5
            )

        else:
            bot_response = await self.create_prompt_phase_4_zweite_session(
                chat_id, message
            )
            await self.update_database_zweite_session(
                chat_id, message, bot_response, phase=4
            )
        return bot_response

    async def create_prompt_phase_4_zweite_session(self, chat_id: int, message: str):
        self.cur.execute(
            "SELECT Zusammenfassung FROM Zusammenfassung_chat WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 1",
            (chat_id,),
        )
        data = self.cur.fetchone()[0]
        self.cur.execute(
            "SELECT Human, Chatbot FROM Zweite_S WHERE ChatID = ? AND Phase = 4.0 ORDER BY ROWID ASC LIMIT -1 OFFSET 2",
            (chat_id,),
        )
        data2 = self.cur.fetchall()
        self.cur.execute(
            "SELECT Fortschritt FROM Fortschritte WHERE ChatID = ? ORDER BY timestamp DESC LIMIT 1",
            (chat_id,),
        )
        fortschritt_data = self.cur.fetchone()

        
        fortschritt = fortschritt_data[0] if fortschritt_data else None

        

        if fortschritt == "Ja":
            print("Fortschritt ist Ja")
            messages = prompt_list_future_goals_planning_session2.copy()
        else:
            print("Fortschritt ist Nein")
            messages = prompt_list_setting_new_goals_session2.copy()

        
        messages.append({"role": "user", "content": data})
        messages.append(
            {
                "role": "assistant",
                "content": "Wie könntest du dieses Ergebnis erreichen? Was wäre ein erster kleiner Schritt?",
            }
        )
        for row in data2[:5]:
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "assistant", "content": ai_text})

        messages.append({"role": "user", "content": "Prompt: " + message})
        bot_response = await self.get_api_response(messages)
        if bot_response:
            pos: int = bot_response.find("\nAI: ")
            bot_response = bot_response[pos + 4 :]
        else:
            bot_response = "Something went wrong..."
        return bot_response

    async def count_interactions_zweite_session(self, chat_id: int) -> int:
        self.cur.execute("SELECT COUNT(*) FROM Zweite_S WHERE ChatID = ?", (chat_id,))
        count = self.cur.fetchone()[0]
        return count

    async def create_prompt_zusammenfassen_zweite_session(self, chat_id: int):
        self.cur.execute(
            "SELECT Human, Chatbot FROM Zweite_S WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 30",
            (chat_id,),
        )
        data = self.cur.fetchall()

        
        messages = []

        
        for row in data:
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "system", "content": ai_text})

        
        messages.reverse()

        return messages

    async def create_prompt_zusammenfassen_gpt3_5_zweite_session(
        self, chat_id: int, phase
    ):
        print("Creating zusammenfassung")
        self.cur.execute(
            "SELECT Human, Chatbot FROM Zweite_S WHERE ChatID = ?", (chat_id,)
        )
        data = self.cur.fetchall()

        
        messages = [
            {
                "role": "system",
                "content": "Verhalte dich wie ein Lerncoach. Weiche nicht von deiner Rolle. Fördere individuelles Lernen und stärke Selbstmanagement. Berücksichtige Motivation und unterstütze selbstreguliertes Lernen. Fokus sehr wichtig: Denkweise des Lernenden, nicht Lösungen. Stelle pro Turn eine Frage. Keine Ratschläge oder Richtungen.",
            }
        ]

        
        for row in data:
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "assistant", "content": ai_text})

        messages.append(
            {
                "role": "user",
                "content": "Prompt: "
                + "Fasse den bisherigen Chatverlauf in einem Satz zusammen. Fange an mit: Lass uns den bisherigen Chatverlauf zusammenfassen. Wir haben uns über folgendes unterhalten:...",
            }
        )
        zusammenfasssung = await self.get_api_response(messages, "gpt-3.5-turbo", 500)
        current_timestamp = int(time.time())
        self.cur.execute(
            "INSERT INTO Zusammenfassung_chat (ChatID, Zusammenfassung, Phase, timestamp) VALUES (?, ?, ?, ?)",
            (chat_id, zusammenfasssung, phase, current_timestamp),
        )
        self.conn.commit()
        if zusammenfasssung:
            pos: int = zusammenfasssung.find("\nAI: ")
            zusammenfasssung = zusammenfasssung[pos + 4 :]
        else:
            zusammenfasssung = "Something went wrong..."

        return zusammenfasssung

    ################## Neutraler Chatbot zeite Session #####################

    async def create_prompt_neutral_zweite_session(self, chat_id: int):
        self.cur.execute(
            "SELECT Human, Chatbot FROM Zweite_S WHERE ChatID = ? ORDER BY ROWID DESC LIMIT 10",
            (chat_id,),
        )
        data = self.cur.fetchall()
        print(f"Das ist der Chatverlauf: {data}")
        messages = [
            {
                "role": "system",
                "content": "Verhalte dich wie ein Lernassistent. Helfe dem Klienten eine Lösung zu finden. Versuche den Klienten mit offenen Fragen zu einem aktiven Gespräch zu animieren, frage nach Kontext. Stelle pro Turn eine Frage. Halte deinen Redeanteil kurz."
            }
        ]

        
        for row in reversed(data[:3]):
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "assistant", "content": ai_text})

        return messages

    async def get_response_neutral_zweite_session(
        self, chat_id: int, message: str
    ) -> str:
        count = await self.count_interactions_neutral_zweite_session(chat_id)
        if count == 15:  # ANPASSEN
            zusammenfassung = (
                await self.create_prompt_zusammenfassen_gpt3_5_neutral_zweite_session(
                    chat_id
                )
            )
            await self.update_database_zweite_session(
                chat_id, message, zusammenfassung, phase=1, Gruppe="NC"
            )
            return zusammenfassung + "\n\n" + end_chat_zweite_session.format(chat_id)
        elif count > 15:  # ANPASSEN
            return "Du hast den Chatbot bereits abgeschlossen"
        else:
            prompt = await self.create_prompt_neutral_zweite_session(chat_id)
            prompt.append({"role": "user", "content": "Prompt: " + message})
            bot_response = await self.get_api_response(prompt, max_tokens=500)

            if bot_response:
                pos: int = bot_response.find("\nChatbot: ")
                bot_response = bot_response[pos + 4 :]
            else:
                bot_response = "Something went wrong..."
            await self.update_database_zweite_session(chat_id, message, bot_response, phase=1, Gruppe="NC")
            return bot_response

    async def create_prompt_zusammenfassen_gpt3_5_neutral_zweite_session(
        self, chat_id: int
    ):
        print("Creating zusammenfassung")
        self.cur.execute(
            "SELECT Human, Chatbot FROM Zweite_S WHERE ChatID = ?", (chat_id,)
        )
        data = self.cur.fetchall()

        
        messages = [
            {
                "role": "system",
                "content": "Du bist ein Chatbot, der versucht Studenten beim lernen zu helfen. Halte die Antowrten kurz",
            }
        ]

        
        for row in data:
            human_text = row[0]
            ai_text = row[1] if row[1] else ""
            messages.append({"role": "user", "content": human_text})
            if ai_text:
                messages.append({"role": "assistant", "content": ai_text})

        messages.append(
            {
                "role": "user",
                "content": "Prompt: "
                + "Fasse den bisherigen Chatverlauf in einem Satz zusammen. Fange an mit: Lass uns den bisherigen Chatverlauf zusammenfassen. Wir haben uns über folgendes unterhalten:...\n",
            }
        )
        zusammenfasssung = await self.get_api_response(messages, "gpt-3.5-turbo", 300)
        current_timestamp = int(time.time())
        self.cur.execute(
            "INSERT INTO Zusammenfassung_chat (ChatID, Zusammenfassung, Phase, timestamp) VALUES (?, ?, ?, ?)",
            (chat_id, zusammenfasssung, 50, current_timestamp),
        )
        self.conn.commit()
        if zusammenfasssung:
            pos: int = zusammenfasssung.find("\nAI: ")
            zusammenfasssung = zusammenfasssung[pos + 4 :]
        else:
            zusammenfasssung = "Something went wrong..."

        return zusammenfasssung

    async def count_interactions_neutral_zweite_session(self, chat_id: int) -> int:
        self.cur.execute("SELECT COUNT(*) FROM Zweite_S WHERE ChatID = ?", (chat_id,))
        count = self.cur.fetchone()[0]
        return count
